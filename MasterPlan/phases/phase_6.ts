
import { PlanPhase } from '../types';

export const phase6: PlanPhase = { 
  id: 6, 
  title: "Backend: Sostenibilità & Caching", 
  desc: "Hashing differenziale, Persistenza Audit.",
  tools: ["Kimi K2.5 (Analysis)", "Redis/DB"],
  cost: "SAVINGS: 60% vs Raw API",
  details: "Logica di ottimizzazione chiamate AI e persistenza dati temporanea.",
  prompts: [
    "SYSTEM ROLE: Backend Architect.",
    "*** CONTEXT & LOGIC RULES (DA IMPLEMENTARE) ***\n1. SCANNING DIFFERENZIALE (Hash Check): Prima di chiamare l'AI, confronta l'ID del componente e l'Hash dei dati. Se invariato, recupera il report dal database.\n2. PERSISTENZA AUDIT: Se un utente esegue una scansione su un wireframe (es. Frame A) e non risolve i problemi, poi cambia selezione e ritorna su Frame A, DEVE rivedere i problemi precedenti senza rieseguire la scansione (Cost Saving).\n3. RETENTION POLICY: I dati di cache e i report temporanei vengono cancellati automaticamente dopo 1 ORA per garantire la sostenibilità del database. Questa regola va riportata in Privacy Policy e T&C.\n\n*** DATA ENGINEERING PROTOCOLS ***\n4. PROTOCOLLO DI TRADUZIONE (The Sanitizer Bridge)\n- Problema: I nodi Figma sono oggetti giganti con riferimenti circolari. Non inviare MAI il nodo grezzo.\n- Soluzione: Il Controller deve 'appiattire' il nodo prima dell'invio. Rimuovi dati binari, converti RGBA in Hex, ignora nodi invisibili, tronca testi > 500 caratteri.\n\n5. SEMANTIC HASHING STRATEGY\n- Calcolo Hash: Deve basarsi SOLO su: Struttura Gerarchica + Nomi Layer + Stili Applicati + Contenuto Testuale.\n- IGNORARE: ID del nodo (cambia al copy-paste), Coordinate X/Y assolute (spostare non è modificare), Timestamp.\n\n*** OPTIMIZATION PROTOCOLS (FINE TUNING) ***\n6. BATCHING INTELLIGENTE (Load Balancing)\n- Problema: Richieste su >50 nodi causano Timeout o Rate Limit.\n- Regola: Il Controller deve dividere il payload in 'Chunks' (es. gruppi di 5). Esecuzione seriale o parallela (max 3). UI mostra progress bar reale.\n\n7. ASTRAZIONE ASSET (Code Gen Efficiency)\n- Problema: L'AI prova a scrivere SVG inline o Base64, bruciando output tokens.\n- Regola: I nodi VECTOR/IMAGE/BOOLEAN vanno sostituiti nel JSON inviato con `{ type: 'ASSET_REF', name: 'icon_name' }`. L'AI deve generare `<Icon name='...' />` o `<img src='...' />`.\n\n8. CONTEXT WINDOWING DINAMICO (Cost Control)\n- Problema: Inviare l'intero Design System (2000 token) ogni volta è costoso.\n- Regola: Injection Selettiva. Se Audit = 'Visual', invia solo Colori/Font. Se Audit = 'Layout', invia Spacing/Grid. Troncare payload > 4000 chars.\n\n9. STANDARD METAFILE STRATEGY (Deep Sync)\n- Problema: 'Confrontare col codice' è vago e lento se si legge il file .tsx raw.\n- Regola: Il confronto avviene contro un file `comtra.meta.json` (Firma del componente) generato lato Repo/Storybook. Il plugin scarica solo questo JSON leggero per calcolare il Drift.\n\n*** SAFETY & KILL SWITCHES (EXTREME SUSTAINABILITY) ***\n10. TOKEN HARD CAP (The Gatekeeper)\n- Problema: Un payload >500 nodi o profondità eccessiva costa €2-5 o crasha (Payload Too Large).\n- Regola: Conta i nodi ricorsivamente PRIMA del processing.\n  • IF node_count > 500: Blocca tutto, chiedi di selezionare un sotto-elemento.\n  • IF depth > 8: Taglia l'albero (i nodi profondi non servono al contesto).\n\n11. TRANSAZIONE ATOMICA (The Bank Teller)\n- Problema: Iniziare un \"Fix All\" su 50 item e fermarsi a metà per mancanza fondi crea stato inconsistente.\n- Regola: Calcolo preventivo All-or-Nothing.\n  • `Costo_Totale = Issues * Costo_Unitario`.\n  • IF `User_Credits < Costo_Totale`: Blocca TUTTO preventivamente, mostra Upsell. Mai iniziare lavori che non si possono finire.\n\n12. CIRCUIT BREAKER (Anti-Loop)\n- Problema: L'AI restituisce JSON rotto. Il retry loop brucia token inutilmente.\n- Regola: Max 1 Retry per errore tecnico (temp 0). Se fallisce ancora: STOP IMMEDIATO. Mostra errore statico (\"AI Confused\"), NON scalare crediti.\n\n13. OUTPUT DETERMINISTICO (No Creative Writing)\n- Problema: L'AI chiacchierona (\"Ecco il codice...\") rompe il parsing e costa token.\n- Regola: Forzare `response_format: { type: \"json_object\" }`. Prompt: \"Do NOT include markdown formatting, explanations, or conversational filler. Output ONLY the raw JSON string.\"\n\n14. COMPRESSIONE VISIONE (Client-Side Downsampling)\n- Problema: Upload di PNG 4K (5-10MB) manda in timeout le Edge Function e rallenta l'UX senza valore aggiunto per l'AI.\n- Regola: Il Controller DEVE ridimensionare le immagini localmente prima dell'upload.\n  • MAX_DIMENSION: 1024px.\n  • QUALITY: 0.6 (JPEG).\n  • Se il nodo è vettoriale/testo puro, invia JSON. Se serve screenshot, comprimilo.\n\n15. BUDGET TOKEN ADATTIVO (Output Leash)\n- Problema: max_tokens fisso (es. 4096) su task piccoli espone al rischio di loop infiniti o verbosità costosa.\n- Regola: Calcolare `max_tokens` dinamicamente in base alla complessità dell'input.\n  • Formula: `Predicted_Output = Input_Nodes_Count * 150 tokens`.\n  • Clamp: Min 500, Max 4000.\n\n16. TOKEN JSON CLEANING PIPELINE (STYLE DICTIONARY FLOW)\n- Obiettivo: Pulire il JSON delle variabili estratte da Figma per renderlo compatibile con Style Dictionary e pipeline di codice.\n- Reference Process: https://www.linkedin.com/posts/minh-truong-20b1a9194_designsystem-designtoken-designsystempipleline-activity-7400905905451671552-3rnc/\n- Action: Implementare transformer che rimuove metadati Figma, risolve gli alias e normalizza la gerarchia prima dell'export.",
    "TASK: Implementa middleware di caching basato su SHA-256, policy di retention a 1 ora e pipeline di pulizia Token JSON."
  ],
  section: "INFRASTRUCTURE & OPERATIONS"
};
